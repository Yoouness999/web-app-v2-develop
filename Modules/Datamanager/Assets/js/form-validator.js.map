{"version":3,"sources":["form-validator.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"form-validator.js","sourcesContent":["(function() {\n  var $;\n\n  $ = angular.element;\n\n  angular.module('validator.directive', ['validator.provider']).directive('validator', [\n    '$injector', function($injector) {\n      return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function(scope, element, attrs, ctrl) {\n          var $parse, $validator, isAcceptTheBroadcast, model, observerRequired, onBlur, registerRequired, removeRule, rules, validate;\n          $validator = $injector.get('$validator');\n          $parse = $injector.get('$parse');\n          model = $parse(attrs.ngModel);\n          rules = [];\n          validate = function(from, args) {\n            var errorCount, increaseSuccessCount, rule, successCount, _fn, _i, _len;\n            if (args == null) {\n              args = {};\n            }\n\n            /*\n            Validate this element with all rules.\n            @param from: 'watch', 'blur' or 'broadcast'\n            @param args:\n                success(): success callback (this callback will return success count)\n                error(): error callback (this callback will return error count)\n                oldValue: the old value of $watch\n             */\n            successCount = 0;\n            errorCount = 0;\n            increaseSuccessCount = function() {\n              var rule, _i, _len;\n              if (++successCount >= rules.length) {\n                ctrl.$setValidity(attrs.ngModel, true);\n                for (_i = 0, _len = rules.length; _i < _len; _i++) {\n                  rule = rules[_i];\n                  rule.success(model(scope), scope, element, attrs, $injector);\n                }\n                if (typeof args.success === \"function\") {\n                  args.success();\n                }\n              }\n            };\n            if (rules.length === 0) {\n              return increaseSuccessCount();\n            }\n            _fn = function(rule) {\n              return rule.validator(model(scope), scope, element, attrs, {\n                success: function() {\n                  return increaseSuccessCount();\n                },\n                error: function() {\n                  if (rule.enableError && ++errorCount === 1) {\n                    ctrl.$setValidity(attrs.ngModel, false);\n                    rule.error(model(scope), scope, element, attrs, $injector);\n                  }\n                  if ((typeof args.error === \"function\" ? args.error() : void 0) === 1) {\n                    try {\n                      element[0].scrollIntoViewIfNeeded();\n                    } catch (_error) {}\n                    return element[0].select();\n                  }\n                }\n              });\n            };\n            for (_i = 0, _len = rules.length; _i < _len; _i++) {\n              rule = rules[_i];\n              switch (from) {\n                case 'blur':\n                  if (rule.invoke !== 'blur') {\n                    continue;\n                  }\n                  rule.enableError = true;\n                  break;\n                case 'watch':\n                  if (rule.invoke !== 'watch' && !rule.enableError) {\n                    increaseSuccessCount();\n                    continue;\n                  }\n                  break;\n                case 'broadcast':\n                  rule.enableError = true;\n                  break;\n              }\n              _fn(rule);\n            }\n          };\n          registerRequired = function() {\n            var rule;\n            rule = $validator.getRule('required');\n            if (rule == null) {\n              rule = $validator.convertRule('required', {\n                validator: /^.+$/,\n                invoke: 'watch'\n              });\n            }\n            return rules.push(rule);\n          };\n          removeRule = function(name) {\n\n            /*\n            Remove the rule in rules by the name.\n             */\n            var index, _i, _ref, _ref1, _results;\n            _results = [];\n            for (index = _i = 0, _ref = rules.length; _i < _ref; index = _i += 1) {\n              if (!(((_ref1 = rules[index]) != null ? _ref1.name : void 0) === name)) {\n                continue;\n              }\n              rules[index].success(model(scope), scope, element, attrs, $injector);\n              rules.splice(index, 1);\n              _results.push(index--);\n            }\n            return _results;\n          };\n          attrs.$observe('validator', function(value) {\n            var match, name, rule, ruleNames, _i, _len, _results;\n            rules.length = 0;\n            if (observerRequired.validatorRequired || observerRequired.required) {\n              registerRequired();\n            }\n            match = value.match(/^\\/(.*)\\/$/);\n            if (match) {\n              rule = $validator.convertRule('dynamic', {\n                validator: RegExp(match[1]),\n                invoke: attrs.validatorInvoke,\n                error: attrs.validatorError\n              });\n              rules.push(rule);\n              return;\n            }\n            match = value.match(/^\\[(.+)\\]$/);\n            if (match) {\n              ruleNames = match[1].split(',');\n              _results = [];\n              for (_i = 0, _len = ruleNames.length; _i < _len; _i++) {\n                name = ruleNames[_i];\n                rule = $validator.getRule(name.replace(/^\\s+|\\s+$/g, ''));\n                if (typeof rule.init === \"function\") {\n                  rule.init(scope, element, attrs, $injector);\n                }\n                if (rule) {\n                  _results.push(rules.push(rule));\n                } else {\n                  _results.push(void 0);\n                }\n              }\n              return _results;\n            }\n          });\n          attrs.$observe('validatorError', function(value) {\n            var match, rule;\n            match = attrs.validator.match(/^\\/(.*)\\/$/);\n            if (match) {\n              removeRule('dynamic');\n              rule = $validator.convertRule('dynamic', {\n                validator: RegExp(match[1]),\n                invoke: attrs.validatorInvoke,\n                error: value\n              });\n              return rules.push(rule);\n            }\n          });\n          observerRequired = {\n            validatorRequired: false,\n            required: false\n          };\n          attrs.$observe('validatorRequired', function(value) {\n            if (value && value !== 'false') {\n              registerRequired();\n              return observerRequired.validatorRequired = true;\n            } else if (observerRequired.validatorRequired) {\n              removeRule('required');\n              return observerRequired.validatorRequired = false;\n            }\n          });\n          attrs.$observe('required', function(value) {\n            if (value && value !== 'false') {\n              registerRequired();\n              return observerRequired.required = true;\n            } else if (observerRequired.required) {\n              removeRule('required');\n              return observerRequired.required = false;\n            }\n          });\n          isAcceptTheBroadcast = function(broadcast, modelName) {\n            var anyHashKey, dotIndex, itemExpression, itemModel;\n            if (modelName) {\n              if (attrs.validatorGroup === modelName) {\n                return true;\n              }\n              if (broadcast.targetScope === scope) {\n                return attrs.ngModel.indexOf(modelName) === 0;\n              } else {\n                anyHashKey = function(targetModel, hashKey) {\n                  var key, x;\n                  for (key in targetModel) {\n                    x = targetModel[key];\n                    switch (typeof x) {\n                      case 'string':\n                        if (key === '$$hashKey' && x === hashKey) {\n                          return true;\n                        }\n                        break;\n                      case 'object':\n                        if (anyHashKey(x, hashKey)) {\n                          return true;\n                        }\n                        break;\n                    }\n                  }\n                  return false;\n                };\n                dotIndex = attrs.ngModel.indexOf('.');\n                itemExpression = dotIndex >= 0 ? attrs.ngModel.substr(0, dotIndex) : attrs.ngModel;\n                itemModel = $parse(itemExpression)(scope);\n                return anyHashKey($parse(modelName)(broadcast.targetScope), itemModel.$$hashKey);\n              }\n            }\n            return true;\n          };\n          scope.$on($validator.broadcastChannel.prepare, function(self, object) {\n            if (!isAcceptTheBroadcast(self, object.model)) {\n              return;\n            }\n            return object.accept();\n          });\n          scope.$on($validator.broadcastChannel.start, function(self, object) {\n            if (!isAcceptTheBroadcast(self, object.model)) {\n              return;\n            }\n            return validate('broadcast', {\n              success: object.success,\n              error: object.error\n            });\n          });\n          scope.$on($validator.broadcastChannel.reset, function(self, object) {\n            var rule, _i, _len;\n            if (!isAcceptTheBroadcast(self, object.model)) {\n              return;\n            }\n            for (_i = 0, _len = rules.length; _i < _len; _i++) {\n              rule = rules[_i];\n              rule.success(model(scope), scope, element, attrs, $injector);\n              if (rule.invoke !== 'watch') {\n                rule.enableError = false;\n              }\n            }\n            return ctrl.$setValidity(attrs.ngModel, true);\n          });\n          scope.$watch(attrs.ngModel, function(newValue, oldValue) {\n            if (newValue === oldValue) {\n              return;\n            }\n            return validate('watch', {\n              oldValue: oldValue\n            });\n          });\n          onBlur = function() {\n            if (scope.$root.$$phase) {\n              return validate('blur');\n            } else {\n              return scope.$apply(function() {\n                return validate('blur');\n              });\n            }\n          };\n          $(element).bind('blur', onBlur);\n          return scope.$on('$destroy', function() {\n            return $(element).unbind('blur', onBlur);\n          });\n        }\n      };\n    }\n  ]);\n\n}).call(this);\n\n(function() {\n  angular.module('validator', ['validator.directive']);\n\n}).call(this);\n\n(function() {\n  var $;\n\n  $ = angular.element;\n\n  angular.module('validator.provider', []).provider('$validator', function() {\n    var $injector, $q, $timeout;\n    $injector = null;\n    $q = null;\n    $timeout = null;\n    this.rules = {};\n    this.broadcastChannel = {\n      prepare: '$validatePrepare',\n      start: '$validateStart',\n      reset: '$validateReset'\n    };\n    this.setupProviders = function(injector) {\n      $injector = injector;\n      $q = $injector.get('$q');\n      return $timeout = $injector.get('$timeout');\n    };\n    this.convertError = function(error) {\n\n      /*\n      Convert rule.error.\n      @param error: error messate (string) or function(value, scope, element, attrs, $injector)\n      @return: function(value, scope, element, attrs, $injector)\n       */\n      var errorMessage;\n      if (typeof error === 'function') {\n        return error;\n      }\n      errorMessage = error.constructor === String ? error : '';\n      return function(value, scope, element, attrs) {\n        var $label, label, parent, _i, _len, _ref, _results;\n        parent = $(element).parent();\n        _results = [];\n        while (parent.length !== 0) {\n          if (parent.hasClass('form-group')) {\n            parent.addClass('has-error');\n            _ref = parent.find('label');\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              label = _ref[_i];\n              if ($(label).hasClass('error')) {\n                $(label).remove();\n              }\n            }\n            $label = $(\"<label class='control-label error'>\" + errorMessage + \"</label>\");\n            if (attrs.id) {\n              $label.attr('for', attrs.id);\n            }\n            if ($(element).parent().hasClass('input-group')) {\n              $(element).parent().parent().append($label);\n            } else {\n              $(element).parent().append($label);\n            }\n            break;\n          }\n          _results.push(parent = parent.parent());\n        }\n        return _results;\n      };\n    };\n    this.convertSuccess = function(success) {\n\n      /*\n      Convert rule.success.\n      @param success: function(value, scope, element, attrs, $injector)\n      @return: function(value, scope, element, attrs, $injector)\n       */\n      if (typeof success === 'function') {\n        return success;\n      }\n      return function(value, scope, element) {\n        var label, parent, _i, _len, _ref, _results;\n        parent = $(element).parent();\n        _results = [];\n        while (parent.length !== 0) {\n          if (parent.hasClass('has-error')) {\n            parent.removeClass('has-error');\n            _ref = parent.find('label');\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              label = _ref[_i];\n              if ($(label).hasClass('error')) {\n                $(label).remove();\n              }\n            }\n            break;\n          }\n          _results.push(parent = parent.parent());\n        }\n        return _results;\n      };\n    };\n    this.convertValidator = function(validator) {\n\n      /*\n      Convert rule.validator.\n      @param validator: RegExp() or function(value, scope, element, attrs, $injector)\n                                                  { return true / false }\n      @return: function(value, scope, element, attrs, funcs{success, error})\n          (funcs is callback functions)\n       */\n      var func, regex, result;\n      result = function() {};\n      if (validator.constructor === RegExp) {\n        regex = validator;\n        result = function(value, scope, element, attrs, funcs) {\n          if (value == null) {\n            value = '';\n          }\n          if (regex.test(value)) {\n            return typeof funcs.success === \"function\" ? funcs.success() : void 0;\n          } else {\n            return typeof funcs.error === \"function\" ? funcs.error() : void 0;\n          }\n        };\n      } else if (typeof validator === 'function') {\n        func = validator;\n        result = function(value, scope, element, attrs, funcs) {\n          return $q.all([func(value, scope, element, attrs, $injector)]).then(function(objects) {\n            if (objects && objects.length > 0 && objects[0]) {\n              return typeof funcs.success === \"function\" ? funcs.success() : void 0;\n            } else {\n              return typeof funcs.error === \"function\" ? funcs.error() : void 0;\n            }\n          }, function() {\n            return typeof funcs.error === \"function\" ? funcs.error() : void 0;\n          });\n        };\n      }\n      return result;\n    };\n    this.convertRule = (function(_this) {\n      return function(name, object) {\n        var result, _ref, _ref1;\n        if (object == null) {\n          object = {};\n        }\n\n        /*\n        Convert the rule object.\n         */\n        result = {\n          name: name,\n          enableError: object.invoke === 'watch',\n          invoke: object.invoke,\n          init: object.init,\n          validator: (_ref = object.validator) != null ? _ref : function() {\n            return true;\n          },\n          error: (_ref1 = object.error) != null ? _ref1 : '',\n          success: object.success\n        };\n        result.error = _this.convertError(result.error);\n        result.success = _this.convertSuccess(result.success);\n        result.validator = _this.convertValidator(result.validator);\n        return result;\n      };\n    })(this);\n    this.register = function(name, object) {\n      if (object == null) {\n        object = {};\n      }\n\n      /*\n      Register the rule.\n      @params name: The rule name.\n      @params object:\n          invoke: 'watch' or 'blur' or undefined(validate by yourself)\n          init: function(scope, element, attrs, $injector)\n          validator: RegExp() or function(value, scope, element, attrs, $injector)\n          error: string or function(scope, element, attrs)\n          success: function(scope, element, attrs)\n       */\n      return this.rules[name] = this.convertRule(name, object);\n    };\n    this.getRule = function(name) {\n\n      /*\n      Get the rule form $validator.rules by the name.\n      @return rule / null\n       */\n      if (this.rules[name]) {\n        return angular.copy(this.rules[name]);\n      } else {\n        return null;\n      }\n    };\n    this.validate = (function(_this) {\n      return function(scope, model) {\n\n        /*\n        Validate the model.\n        @param scope: The scope.\n        @param model: The model name of the scope or validator-group.\n        @return:\n            @promise success(): The success function.\n            @promise error(): The error function.\n         */\n        var broadcastObject, count, deferred, func, promise;\n        deferred = $q.defer();\n        promise = deferred.promise;\n        count = {\n          total: 0,\n          success: 0,\n          error: 0\n        };\n        func = {\n          promises: {\n            success: [],\n            error: [],\n            then: []\n          },\n          accept: function() {\n            return count.total++;\n          },\n          validatedSuccess: function() {\n            var x, _i, _j, _len, _len1, _ref, _ref1;\n            if (++count.success === count.total) {\n              _ref = func.promises.success;\n              for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                x = _ref[_i];\n                x();\n              }\n              _ref1 = func.promises.then;\n              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n                x = _ref1[_j];\n                x();\n              }\n            }\n            return count.success;\n          },\n          validatedError: function() {\n            var x, _i, _j, _len, _len1, _ref, _ref1;\n            if (count.error++ === 0) {\n              _ref = func.promises.error;\n              for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                x = _ref[_i];\n                x();\n              }\n              _ref1 = func.promises.then;\n              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n                x = _ref1[_j];\n                x();\n              }\n            }\n            return count.error;\n          }\n        };\n        promise.success = function(fn) {\n          func.promises.success.push(fn);\n          return promise;\n        };\n        promise.error = function(fn) {\n          func.promises.error.push(fn);\n          return promise;\n        };\n        promise.then = function(fn) {\n          func.promises.then.push(fn);\n          return promise;\n        };\n        broadcastObject = {\n          model: model,\n          accept: func.accept,\n          success: func.validatedSuccess,\n          error: func.validatedError\n        };\n        scope.$broadcast(_this.broadcastChannel.prepare, broadcastObject);\n        $timeout(function() {\n          var $validator, x, _i, _len, _ref;\n          if (count.total === 0) {\n            _ref = func.promises.success;\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              x = _ref[_i];\n              x();\n            }\n            return;\n          }\n          $validator = $injector.get('$validator');\n          return scope.$broadcast($validator.broadcastChannel.start, broadcastObject);\n        });\n        return promise;\n      };\n    })(this);\n    this.reset = (function(_this) {\n      return function(scope, model) {\n\n        /*\n        Reset validated error messages of the model.\n        @param scope: The scope.\n        @param model: The model name of the scope or validator-group.\n         */\n        return scope.$broadcast(_this.broadcastChannel.reset, {\n          model: model\n        });\n      };\n    })(this);\n    this.get = function($injector) {\n      this.setupProviders($injector);\n      return {\n        rules: this.rules,\n        broadcastChannel: this.broadcastChannel,\n        register: this.register,\n        convertRule: this.convertRule,\n        getRule: this.getRule,\n        validate: this.validate,\n        reset: this.reset\n      };\n    };\n    this.get.$inject = ['$injector'];\n    this.$get = this.get;\n  });\n\n}).call(this);\n"],"sourceRoot":"/source/"}