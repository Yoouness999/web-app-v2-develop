{"version":3,"sources":["form-validator.js"],"names":["$","angular","element","module","directive","$injector","restrict","require","link","scope","attrs","ctrl","$parse","$validator","isAcceptTheBroadcast","model","observerRequired","onBlur","registerRequired","removeRule","rules","validate","get","ngModel","from","args","errorCount","increaseSuccessCount","rule","successCount","_fn","_i","_len","length","$setValidity","success","validator","error","enableError","scrollIntoViewIfNeeded","_error","select","invoke","getRule","convertRule","push","name","index","_ref","_ref1","_results","splice","$observe","value","match","ruleNames","validatorRequired","required","RegExp","validatorInvoke","validatorError","split","replace","init","broadcast","modelName","anyHashKey","dotIndex","itemExpression","itemModel","validatorGroup","targetScope","indexOf","targetModel","hashKey","key","x","substr","$$hashKey","$on","broadcastChannel","prepare","self","object","accept","start","reset","$watch","newValue","oldValue","$root","$$phase","$apply","bind","unbind","call","this","provider","$q","$timeout","setupProviders","injector","convertError","errorMessage","constructor","String","$label","label","parent","hasClass","addClass","find","remove","id","attr","append","convertSuccess","removeClass","convertValidator","func","regex","result","funcs","test","all","then","objects","_this","register","copy","broadcastObject","count","deferred","promise","defer","total","promises","validatedSuccess","_j","_len1","validatedError","fn","$broadcast","$inject","$get"],"mappings":"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","file":"form-validator.min.js","sourcesContent":["(function() {\n  var $;\n\n  $ = angular.element;\n\n  angular.module('validator.directive', ['validator.provider']).directive('validator', [\n    '$injector', function($injector) {\n      return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function(scope, element, attrs, ctrl) {\n          var $parse, $validator, isAcceptTheBroadcast, model, observerRequired, onBlur, registerRequired, removeRule, rules, validate;\n          $validator = $injector.get('$validator');\n          $parse = $injector.get('$parse');\n          model = $parse(attrs.ngModel);\n          rules = [];\n          validate = function(from, args) {\n            var errorCount, increaseSuccessCount, rule, successCount, _fn, _i, _len;\n            if (args == null) {\n              args = {};\n            }\n\n            /*\n            Validate this element with all rules.\n            @param from: 'watch', 'blur' or 'broadcast'\n            @param args:\n                success(): success callback (this callback will return success count)\n                error(): error callback (this callback will return error count)\n                oldValue: the old value of $watch\n             */\n            successCount = 0;\n            errorCount = 0;\n            increaseSuccessCount = function() {\n              var rule, _i, _len;\n              if (++successCount >= rules.length) {\n                ctrl.$setValidity(attrs.ngModel, true);\n                for (_i = 0, _len = rules.length; _i < _len; _i++) {\n                  rule = rules[_i];\n                  rule.success(model(scope), scope, element, attrs, $injector);\n                }\n                if (typeof args.success === \"function\") {\n                  args.success();\n                }\n              }\n            };\n            if (rules.length === 0) {\n              return increaseSuccessCount();\n            }\n            _fn = function(rule) {\n              return rule.validator(model(scope), scope, element, attrs, {\n                success: function() {\n                  return increaseSuccessCount();\n                },\n                error: function() {\n                  if (rule.enableError && ++errorCount === 1) {\n                    ctrl.$setValidity(attrs.ngModel, false);\n                    rule.error(model(scope), scope, element, attrs, $injector);\n                  }\n                  if ((typeof args.error === \"function\" ? args.error() : void 0) === 1) {\n                    try {\n                      element[0].scrollIntoViewIfNeeded();\n                    } catch (_error) {}\n                    return element[0].select();\n                  }\n                }\n              });\n            };\n            for (_i = 0, _len = rules.length; _i < _len; _i++) {\n              rule = rules[_i];\n              switch (from) {\n                case 'blur':\n                  if (rule.invoke !== 'blur') {\n                    continue;\n                  }\n                  rule.enableError = true;\n                  break;\n                case 'watch':\n                  if (rule.invoke !== 'watch' && !rule.enableError) {\n                    increaseSuccessCount();\n                    continue;\n                  }\n                  break;\n                case 'broadcast':\n                  rule.enableError = true;\n                  break;\n              }\n              _fn(rule);\n            }\n          };\n          registerRequired = function() {\n            var rule;\n            rule = $validator.getRule('required');\n            if (rule == null) {\n              rule = $validator.convertRule('required', {\n                validator: /^.+$/,\n                invoke: 'watch'\n              });\n            }\n            return rules.push(rule);\n          };\n          removeRule = function(name) {\n\n            /*\n            Remove the rule in rules by the name.\n             */\n            var index, _i, _ref, _ref1, _results;\n            _results = [];\n            for (index = _i = 0, _ref = rules.length; _i < _ref; index = _i += 1) {\n              if (!(((_ref1 = rules[index]) != null ? _ref1.name : void 0) === name)) {\n                continue;\n              }\n              rules[index].success(model(scope), scope, element, attrs, $injector);\n              rules.splice(index, 1);\n              _results.push(index--);\n            }\n            return _results;\n          };\n          attrs.$observe('validator', function(value) {\n            var match, name, rule, ruleNames, _i, _len, _results;\n            rules.length = 0;\n            if (observerRequired.validatorRequired || observerRequired.required) {\n              registerRequired();\n            }\n            match = value.match(/^\\/(.*)\\/$/);\n            if (match) {\n              rule = $validator.convertRule('dynamic', {\n                validator: RegExp(match[1]),\n                invoke: attrs.validatorInvoke,\n                error: attrs.validatorError\n              });\n              rules.push(rule);\n              return;\n            }\n            match = value.match(/^\\[(.+)\\]$/);\n            if (match) {\n              ruleNames = match[1].split(',');\n              _results = [];\n              for (_i = 0, _len = ruleNames.length; _i < _len; _i++) {\n                name = ruleNames[_i];\n                rule = $validator.getRule(name.replace(/^\\s+|\\s+$/g, ''));\n                if (typeof rule.init === \"function\") {\n                  rule.init(scope, element, attrs, $injector);\n                }\n                if (rule) {\n                  _results.push(rules.push(rule));\n                } else {\n                  _results.push(void 0);\n                }\n              }\n              return _results;\n            }\n          });\n          attrs.$observe('validatorError', function(value) {\n            var match, rule;\n            match = attrs.validator.match(/^\\/(.*)\\/$/);\n            if (match) {\n              removeRule('dynamic');\n              rule = $validator.convertRule('dynamic', {\n                validator: RegExp(match[1]),\n                invoke: attrs.validatorInvoke,\n                error: value\n              });\n              return rules.push(rule);\n            }\n          });\n          observerRequired = {\n            validatorRequired: false,\n            required: false\n          };\n          attrs.$observe('validatorRequired', function(value) {\n            if (value && value !== 'false') {\n              registerRequired();\n              return observerRequired.validatorRequired = true;\n            } else if (observerRequired.validatorRequired) {\n              removeRule('required');\n              return observerRequired.validatorRequired = false;\n            }\n          });\n          attrs.$observe('required', function(value) {\n            if (value && value !== 'false') {\n              registerRequired();\n              return observerRequired.required = true;\n            } else if (observerRequired.required) {\n              removeRule('required');\n              return observerRequired.required = false;\n            }\n          });\n          isAcceptTheBroadcast = function(broadcast, modelName) {\n            var anyHashKey, dotIndex, itemExpression, itemModel;\n            if (modelName) {\n              if (attrs.validatorGroup === modelName) {\n                return true;\n              }\n              if (broadcast.targetScope === scope) {\n                return attrs.ngModel.indexOf(modelName) === 0;\n              } else {\n                anyHashKey = function(targetModel, hashKey) {\n                  var key, x;\n                  for (key in targetModel) {\n                    x = targetModel[key];\n                    switch (typeof x) {\n                      case 'string':\n                        if (key === '$$hashKey' && x === hashKey) {\n                          return true;\n                        }\n                        break;\n                      case 'object':\n                        if (anyHashKey(x, hashKey)) {\n                          return true;\n                        }\n                        break;\n                    }\n                  }\n                  return false;\n                };\n                dotIndex = attrs.ngModel.indexOf('.');\n                itemExpression = dotIndex >= 0 ? attrs.ngModel.substr(0, dotIndex) : attrs.ngModel;\n                itemModel = $parse(itemExpression)(scope);\n                return anyHashKey($parse(modelName)(broadcast.targetScope), itemModel.$$hashKey);\n              }\n            }\n            return true;\n          };\n          scope.$on($validator.broadcastChannel.prepare, function(self, object) {\n            if (!isAcceptTheBroadcast(self, object.model)) {\n              return;\n            }\n            return object.accept();\n          });\n          scope.$on($validator.broadcastChannel.start, function(self, object) {\n            if (!isAcceptTheBroadcast(self, object.model)) {\n              return;\n            }\n            return validate('broadcast', {\n              success: object.success,\n              error: object.error\n            });\n          });\n          scope.$on($validator.broadcastChannel.reset, function(self, object) {\n            var rule, _i, _len;\n            if (!isAcceptTheBroadcast(self, object.model)) {\n              return;\n            }\n            for (_i = 0, _len = rules.length; _i < _len; _i++) {\n              rule = rules[_i];\n              rule.success(model(scope), scope, element, attrs, $injector);\n              if (rule.invoke !== 'watch') {\n                rule.enableError = false;\n              }\n            }\n            return ctrl.$setValidity(attrs.ngModel, true);\n          });\n          scope.$watch(attrs.ngModel, function(newValue, oldValue) {\n            if (newValue === oldValue) {\n              return;\n            }\n            return validate('watch', {\n              oldValue: oldValue\n            });\n          });\n          onBlur = function() {\n            if (scope.$root.$$phase) {\n              return validate('blur');\n            } else {\n              return scope.$apply(function() {\n                return validate('blur');\n              });\n            }\n          };\n          $(element).bind('blur', onBlur);\n          return scope.$on('$destroy', function() {\n            return $(element).unbind('blur', onBlur);\n          });\n        }\n      };\n    }\n  ]);\n\n}).call(this);\n\n(function() {\n  angular.module('validator', ['validator.directive']);\n\n}).call(this);\n\n(function() {\n  var $;\n\n  $ = angular.element;\n\n  angular.module('validator.provider', []).provider('$validator', function() {\n    var $injector, $q, $timeout;\n    $injector = null;\n    $q = null;\n    $timeout = null;\n    this.rules = {};\n    this.broadcastChannel = {\n      prepare: '$validatePrepare',\n      start: '$validateStart',\n      reset: '$validateReset'\n    };\n    this.setupProviders = function(injector) {\n      $injector = injector;\n      $q = $injector.get('$q');\n      return $timeout = $injector.get('$timeout');\n    };\n    this.convertError = function(error) {\n\n      /*\n      Convert rule.error.\n      @param error: error messate (string) or function(value, scope, element, attrs, $injector)\n      @return: function(value, scope, element, attrs, $injector)\n       */\n      var errorMessage;\n      if (typeof error === 'function') {\n        return error;\n      }\n      errorMessage = error.constructor === String ? error : '';\n      return function(value, scope, element, attrs) {\n        var $label, label, parent, _i, _len, _ref, _results;\n        parent = $(element).parent();\n        _results = [];\n        while (parent.length !== 0) {\n          if (parent.hasClass('form-group')) {\n            parent.addClass('has-error');\n            _ref = parent.find('label');\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              label = _ref[_i];\n              if ($(label).hasClass('error')) {\n                $(label).remove();\n              }\n            }\n            $label = $(\"<label class='control-label error'>\" + errorMessage + \"</label>\");\n            if (attrs.id) {\n              $label.attr('for', attrs.id);\n            }\n            if ($(element).parent().hasClass('input-group')) {\n              $(element).parent().parent().append($label);\n            } else {\n              $(element).parent().append($label);\n            }\n            break;\n          }\n          _results.push(parent = parent.parent());\n        }\n        return _results;\n      };\n    };\n    this.convertSuccess = function(success) {\n\n      /*\n      Convert rule.success.\n      @param success: function(value, scope, element, attrs, $injector)\n      @return: function(value, scope, element, attrs, $injector)\n       */\n      if (typeof success === 'function') {\n        return success;\n      }\n      return function(value, scope, element) {\n        var label, parent, _i, _len, _ref, _results;\n        parent = $(element).parent();\n        _results = [];\n        while (parent.length !== 0) {\n          if (parent.hasClass('has-error')) {\n            parent.removeClass('has-error');\n            _ref = parent.find('label');\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              label = _ref[_i];\n              if ($(label).hasClass('error')) {\n                $(label).remove();\n              }\n            }\n            break;\n          }\n          _results.push(parent = parent.parent());\n        }\n        return _results;\n      };\n    };\n    this.convertValidator = function(validator) {\n\n      /*\n      Convert rule.validator.\n      @param validator: RegExp() or function(value, scope, element, attrs, $injector)\n                                                  { return true / false }\n      @return: function(value, scope, element, attrs, funcs{success, error})\n          (funcs is callback functions)\n       */\n      var func, regex, result;\n      result = function() {};\n      if (validator.constructor === RegExp) {\n        regex = validator;\n        result = function(value, scope, element, attrs, funcs) {\n          if (value == null) {\n            value = '';\n          }\n          if (regex.test(value)) {\n            return typeof funcs.success === \"function\" ? funcs.success() : void 0;\n          } else {\n            return typeof funcs.error === \"function\" ? funcs.error() : void 0;\n          }\n        };\n      } else if (typeof validator === 'function') {\n        func = validator;\n        result = function(value, scope, element, attrs, funcs) {\n          return $q.all([func(value, scope, element, attrs, $injector)]).then(function(objects) {\n            if (objects && objects.length > 0 && objects[0]) {\n              return typeof funcs.success === \"function\" ? funcs.success() : void 0;\n            } else {\n              return typeof funcs.error === \"function\" ? funcs.error() : void 0;\n            }\n          }, function() {\n            return typeof funcs.error === \"function\" ? funcs.error() : void 0;\n          });\n        };\n      }\n      return result;\n    };\n    this.convertRule = (function(_this) {\n      return function(name, object) {\n        var result, _ref, _ref1;\n        if (object == null) {\n          object = {};\n        }\n\n        /*\n        Convert the rule object.\n         */\n        result = {\n          name: name,\n          enableError: object.invoke === 'watch',\n          invoke: object.invoke,\n          init: object.init,\n          validator: (_ref = object.validator) != null ? _ref : function() {\n            return true;\n          },\n          error: (_ref1 = object.error) != null ? _ref1 : '',\n          success: object.success\n        };\n        result.error = _this.convertError(result.error);\n        result.success = _this.convertSuccess(result.success);\n        result.validator = _this.convertValidator(result.validator);\n        return result;\n      };\n    })(this);\n    this.register = function(name, object) {\n      if (object == null) {\n        object = {};\n      }\n\n      /*\n      Register the rule.\n      @params name: The rule name.\n      @params object:\n          invoke: 'watch' or 'blur' or undefined(validate by yourself)\n          init: function(scope, element, attrs, $injector)\n          validator: RegExp() or function(value, scope, element, attrs, $injector)\n          error: string or function(scope, element, attrs)\n          success: function(scope, element, attrs)\n       */\n      return this.rules[name] = this.convertRule(name, object);\n    };\n    this.getRule = function(name) {\n\n      /*\n      Get the rule form $validator.rules by the name.\n      @return rule / null\n       */\n      if (this.rules[name]) {\n        return angular.copy(this.rules[name]);\n      } else {\n        return null;\n      }\n    };\n    this.validate = (function(_this) {\n      return function(scope, model) {\n\n        /*\n        Validate the model.\n        @param scope: The scope.\n        @param model: The model name of the scope or validator-group.\n        @return:\n            @promise success(): The success function.\n            @promise error(): The error function.\n         */\n        var broadcastObject, count, deferred, func, promise;\n        deferred = $q.defer();\n        promise = deferred.promise;\n        count = {\n          total: 0,\n          success: 0,\n          error: 0\n        };\n        func = {\n          promises: {\n            success: [],\n            error: [],\n            then: []\n          },\n          accept: function() {\n            return count.total++;\n          },\n          validatedSuccess: function() {\n            var x, _i, _j, _len, _len1, _ref, _ref1;\n            if (++count.success === count.total) {\n              _ref = func.promises.success;\n              for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                x = _ref[_i];\n                x();\n              }\n              _ref1 = func.promises.then;\n              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n                x = _ref1[_j];\n                x();\n              }\n            }\n            return count.success;\n          },\n          validatedError: function() {\n            var x, _i, _j, _len, _len1, _ref, _ref1;\n            if (count.error++ === 0) {\n              _ref = func.promises.error;\n              for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                x = _ref[_i];\n                x();\n              }\n              _ref1 = func.promises.then;\n              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n                x = _ref1[_j];\n                x();\n              }\n            }\n            return count.error;\n          }\n        };\n        promise.success = function(fn) {\n          func.promises.success.push(fn);\n          return promise;\n        };\n        promise.error = function(fn) {\n          func.promises.error.push(fn);\n          return promise;\n        };\n        promise.then = function(fn) {\n          func.promises.then.push(fn);\n          return promise;\n        };\n        broadcastObject = {\n          model: model,\n          accept: func.accept,\n          success: func.validatedSuccess,\n          error: func.validatedError\n        };\n        scope.$broadcast(_this.broadcastChannel.prepare, broadcastObject);\n        $timeout(function() {\n          var $validator, x, _i, _len, _ref;\n          if (count.total === 0) {\n            _ref = func.promises.success;\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              x = _ref[_i];\n              x();\n            }\n            return;\n          }\n          $validator = $injector.get('$validator');\n          return scope.$broadcast($validator.broadcastChannel.start, broadcastObject);\n        });\n        return promise;\n      };\n    })(this);\n    this.reset = (function(_this) {\n      return function(scope, model) {\n\n        /*\n        Reset validated error messages of the model.\n        @param scope: The scope.\n        @param model: The model name of the scope or validator-group.\n         */\n        return scope.$broadcast(_this.broadcastChannel.reset, {\n          model: model\n        });\n      };\n    })(this);\n    this.get = function($injector) {\n      this.setupProviders($injector);\n      return {\n        rules: this.rules,\n        broadcastChannel: this.broadcastChannel,\n        register: this.register,\n        convertRule: this.convertRule,\n        getRule: this.getRule,\n        validate: this.validate,\n        reset: this.reset\n      };\n    };\n    this.get.$inject = ['$injector'];\n    this.$get = this.get;\n  });\n\n}).call(this);\n"],"sourceRoot":"/source/"}